```python
from ctypes import *
import unicorn as uc
import struct
from pwn import *

# This is just to print each instruction address as it's emulated
def hook_call(uc_engine, mem_type, address, size):
    eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP)
    print(f"EIP: {hex(eip-0x10000)}")
    return True


buf = open('Guloader_stage2.bin', 'rb').read()

uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32)
STACK_ADDR = 0x900000
CODE_ADDR = 0x10000

# Load shellcode into mem
uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL)
uc_engine.mem_write(CODE_ADDR, buf)

# Set shellcode entrypoint
uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR)

# Setup the stack memory
uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL)
uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR)
uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR)


# This is our hook just for fun
#hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None)


# Setup our arguments/buffers

EAX_BUFF = 0x500000
uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL)
uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF)

# This sort of works like a 'push' to push the buffer address onto the stack
EBP_BUFF = 0x600000
uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL)
uc_engine.mem_write(STACK_ADDR, struct.pack('<I',EBP_BUFF))


EDI_BUFF = 0x700000
uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL)
uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF)


ARG_BUFF = 0x400000
uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL)
uc_engine.mem_write(STACK_ADDR + 4, struct.pack('<I',ARG_BUFF))

FN_START = 0X08D44 + CODE_ADDR
FN_END = 0x08F81 + CODE_ADDR        # not get ret ins

uc_engine.emu_start(FN_START, FN_END, 0, 0)

buf_data= uc_engine.mem_read(ARG_BUFF,0x100)
print(buf_data)
data_len=u32(buf_data[:4])
real_data=buf_data[4:4+data_len]

key = bytes.fromhex('3d4f0b6d845f58cbf8844e9ab35781156c68109175e8c42901f8ee2b78c4926631939c778b2a48e0d8ea0dd585')
key=key[:len(real_data)]

print(xor(real_data,key))
```
