## 1. Thu nhập thông tin

- Dùng `Die`:

-> Compile bằng ` MS Visual C++ 2005`.

-> Sử dụng thư viện ` MFC library` 

-> High entropy -> có thể bị packed. 

-> File `.dll` `32bit`


- Dùng `PEbear`:

-> Chương trìng có 2 export functions là: `DllRegisterServer` và `DllUnregisterServer`


- Dùng `capa`:

![image](https://user-images.githubusercontent.com/91442807/214837286-963ac755-32f2-4099-a89d-ed30f4340a9c.png)

-> Có sử dụng thuật toán RC4.

## 2. Unpacking

- Nhận thấy chương trình sử dụng các API: `VirtualAlloc`, `NtResumeThread`, `WriteProcessMemory` -> process hollowing

- Có thể sử dụng `hollow_hunter` để dump các file process.

- Cách sử dụng:

```
hollows_hunter64 /loop
rundll32 mas_3.bin,#1
```
- Kết quả:

![image](https://user-images.githubusercontent.com/91442807/214843515-ec71cf3b-df86-4a0a-8a13-680ed40660ba.png)

-> Ta chọn file có dung lượng cao hơn

- Load vào PEbear:

![image](https://user-images.githubusercontent.com/91442807/214843701-423d9fdd-981a-414a-bdcd-40c7787fae09.png)

-> Mấy cái section được map hết ko lỗi.

## 3. Reverse

- Kết quả `capa explorer`:

![image](https://user-images.githubusercontent.com/91442807/214857211-a02779eb-25b9-46e8-bc56-a1fcfe9ac6a8.png)

-> Dùng thuật toán hashing `murmur3`: `Kết quả sau khi hash là giá trị 32-bit hoặc 128-bit`

- `import` section không có gì -> khả năng cao là `API resolve dynamically`

- `strings` section chỉ có 3 dòng -> khả năng là `string decryption dynamically`

- Hàm `DllRegisterServer`:

![image](https://user-images.githubusercontent.com/91442807/215014341-b73add34-6414-463b-8174-e8f1b1188cd4.png)

- Hàm `sub_41A1FD0`:

![image](https://user-images.githubusercontent.com/91442807/215014414-303783af-0647-45b8-8c60-36f77dc3d332.png)

-> Control flow flattening

- Không phân tích nổi nên ta sẽ quan sát các hàm được gọi nhiều (khả năng cao dùng dùng resolve API hay decrypt strings):

```python
import idc
import idautils

ea= 0x41A1FD0

start = idc.get_func_attr(ea, FUNCATTR_START)
end_d = idc.get_func_attr(ea, FUNCATTR_END)
end=end_d -1

while start<=end:
    curr_addr= start
    ins= idc.generate_disasm_line(curr_addr,1)
    if "call" in ins and "sub_" in ins:
        func_addr= idc.get_operand_value(curr_addr,0)
        func_xref= len(list(idautils.CodeRefsTo(func_addr, 0)))
        print("\n")
        print(f"{ins} - {func_xref}")

        ea1= func_addr
        start1 = idc.get_func_attr(ea1, FUNCATTR_START)
        end1_d = idc.get_func_attr(ea1, FUNCATTR_END)
        end1=end1_d -1

        while start1 <= end1:
            curr_addr1= start1
            ins1= idc.generate_disasm_line(curr_addr1,1)
            if "call" in ins1 and "sub_" in ins1:
                func_addr1= idc.get_operand_value(curr_addr1,0)
                func_xref1= len(list(idautils.CodeRefsTo(func_addr1, 0)))
                print(f"    {ins1} - {func_xref1}")

            next_addr1= idc.next_head(curr_addr1)
            start1= next_addr1

    next_addr= idc.next_head(curr_addr)
    start= next_addr
```

- Kết quả:

![image](https://user-images.githubusercontent.com/91442807/215236936-dcb86384-6beb-43e3-8911-175045e94f02.png)

- Quan sát thì ta thấy `sub_4194BB4` được gọi khá nhiều với 45 lần.

- 1 hàm gọi nó:

![image](https://user-images.githubusercontent.com/91442807/215237015-feffa35e-3edf-4ab5-8599-06a5690e468d.png)

- Ta thấy có sử dụng `mảng dword` ở tham số thứ 2 mà mảng này lại nằm ở phần `.text section` -> khả năng là `string decryption`

- Vô coi thử:

![image](https://user-images.githubusercontent.com/91442807/215237221-50363866-0751-41de-95ce-576ba00d2232.png)

![image](https://user-images.githubusercontent.com/91442807/215237199-3786a8e3-e84c-4181-907d-d4c423a4023e.png)

-> Ta thấy `v6` giữ giá trị `ecx` tức là tham số thứ 2, sau đó `xor 4_bytes_đầu với 4_bytes_tiếp_theo làm độ dài`, sau đó lấy số lượng bytes tiếp theo dựa trên độ dài đó và xor với 4 bytes đầu.

-> Vậy là chỉ cần tham số thứ 2 của hàm, không liên quan đến các tham số kia.

- Script lấy địa chỉ tham số thứ 2 của hàm: 

```python
from pwn import *
import idc
import idautils


ea= 0x4194BB4
ref_lst= list(idautils.CodeRefsTo(ea, 0))
# print(ref_lst)
dword_lst=[]

for addr in ref_lst:
    curr_addr= addr
    ins_cnt=0
    while True:
        ins= idc.generate_disasm_line(curr_addr, 1)
        if "ecx" in ins and "offset dword_" in ins:
            dword_addr= idc.get_operand_value(curr_addr, 1)
            dword_lst.append(dword_addr)
            break

        prev_addr= idc.prev_head(curr_addr)
        curr_addr=prev_addr
        ins_cnt+=1
        if ins_cnt>=8:
            dword_lst.append(f"{hex(addr)} - error")
            break

assert(len(dword_lst) == len(ref_lst))
print(dword_lst)
```
-> Trong đó có một số địa chỉ không theo điều kiện tìm kiếm của script nên in error(quá lần cnt, không có dword trong ins,...), nên ta sửa lại mấy cái đó bằng tay

- Script decrypt:

```python
from pwn import *

dword_lst=[68753492, 68751872, 68752824, 68753176, 68752872, 68751872, 68751968, 68751872, 68752824, 68753128, 68752872, 68752824, 68751872, 68752016, 68753420, 68751872, 68751920, 68752096, 68753220, 68753392, 68752968, 68752872, 68753016, 68753300, 68753348, 68753588, 68753460, 68753096, 68753016, 68752968, 68752936, 68753064, 68752872, 68751920, 68751636, 68752016, 68751920, 68752584, 68751872, 68753460, 68753540, 68753492, 0x4191084, 0x41910E4]
#0x41a0b16 - error
dword_lst1=[0x4191494, 0x4191344, 0x4191364, 0x4191454, 0x4191324, 0x4191394, 0x41913C4, 0x4191424, 0x41913F4]

for dword_addr in dword_lst1:
    
    data_len= u32(idaapi.get_bytes(dword_addr,4)) ^ u32(idaapi.get_bytes(dword_addr,8)[4:])
    enc_data= idaapi.get_bytes(dword_addr,8+data_len)[8:]
    key_xor= idaapi.get_bytes(dword_addr,4)
    dec_data= xor(key_xor, enc_data)
    # print(dec_data)
    idc.set_name(dword_addr, dec_data.decode(), idaapi.SN_FORCE)
```
- Kết quả:

```
b'%s%s.exe'
b'%s\\%s'
b'ECCPUBLICBLOB'
b'ECDSA_P256'
b'Microsoft Primitive Provider'
b'%s\\%s'
b'%s\\%s%x'
b'%s\\%s'
b'ECCPUBLICBLOB'
b'ECDH_P256'
b'Microsoft Primitive Provider'
b'ECCPUBLICBLOB'
b'%s\\%s'
b'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
b'POST'
b'%s\\%s'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'%s\\regsvr32.exe /s "%s\\%s" %s'
b'%s:Zone.Identifier'
b'WinSta0\\Default'
b'SHA256'
b'Microsoft Primitive Provider'
b'ObjectLength'
b'%s\\*'
b'%s\\%s'
b'%s\\regsvr32.exe /s "%s"'
b'%s%s.dll'
b'KeyDataBlob'
b'ObjectLength'
b'SHA256'
b'HASH'
b'AESR'
b'Microsoft Primitive Provider'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'Content-Type: multipart/form-data; boundary=%s\r\n'
b'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'RNG\xdf'
b'%s\\%s'
b'%s%s.dll'
b'%s\\regsvr32.exe /s "%s" %s'
b'%s%s.exe'
b'%u.%u.%u.%u'
b'Cookie: %s=%s\r\n'
```

```
b'advapi32.dll'
b'bcrypt.dll'
b'shell32.dll'
b'urlmon.dll'
b'userenv.dll'
b'crypt32.dll'
b'shlwapi.dll'
b'wininet.dll'
b'wtsapi32.dll'
```

- Tiếp đến ta coi thử hàm `sub_41AEAA3` được gọi 33 lần:

![image](https://user-images.githubusercontent.com/91442807/215240965-7459fa3f-f1b2-4e27-878d-b3bf5d64807d.png)

- Xem tiếp `sub_419645E`:

![image](https://user-images.githubusercontent.com/91442807/215240975-670473b4-4e8b-4167-9bad-340cac6c55ec.png)

-> Ta thấy `v1` được dùng làm hàm của các tham số -> có thể là API hashing

-> ref vô hàm `sub_41ABFF0` rất nhiều càng củng cố giả thuyết

- sub_41ABFF0:

![image](https://user-images.githubusercontent.com/91442807/215258878-c73a3841-7b4e-46b3-a0f4-332fd17908f1.png)

-> `v4` giữ giá trị `ecx` tức là `giá trị hex` rồi đưa vào hàm `sub_41B1AE9`:

![image](https://user-images.githubusercontent.com/91442807/215258934-897e0fa1-333b-4942-a512-74650a0b8c0c.png)

(Hình trên là kết quả sau khi `add struct`, `chỉnh sửa cấu trúc hàm các thứ`, ..)

-> Nhớ 1 điều rằng `InLoadOrderModuleList` sẽ trỏ tới struct [LDR_MODULE](http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FLDR_MODULE.html)

-> Vậy hàm này dùng để `resolve DLL`

- Qua hàm `sub_41AB558`:

![image](https://user-images.githubusercontent.com/91442807/215271044-cee28417-0167-419f-9dc7-6d6b424a651a.png)

-> Có vẻ hàm có sử dụng hàm `calculate_api_hash`

-> Hàm `calculate_api_hash` tương tự `calculate_dll_hash`, chỉ khác ở chỗ là không có bước đổi kí tự in hoa thành in thường.

-> Trace ngược lại ta thấy tham số cuối của `sub_41ABFF0` chính là giá trị hash của API cần so sánh:

![image](https://user-images.githubusercontent.com/91442807/215270608-191ad116-c04f-4a22-9dde-1c6cb7bd9fff.png)

-> Vậy giờ ta chỉ cần viết sccipt để brute các API thôi còn DLL thì ko cần quan tâm

```python
import json

json_data=json.loads(open("API_list.txt", "rb").read())
API_names=json_data['exports']

api_hash_map={}
def api_hash(api):
    i=0
    for j in range(len(api)):
        i = ((i << 0x10) + (i << 6) + api[j] - i)&0xffffffff
    return i ^ 0x32C9DB43

#print(api_hash(b'GetProcessHeap'))
for i in API_names:
    api_hash_map[api_hash(i.encode())]= i


ea= 0x41ABFF0

import idc
import idautils

ref_lst= list(idautils.CodeRefsTo(ea, 0))
hash_lst=[]

for addr in ref_lst:
    curr_addr= addr

    while True:
        ins= idc.generate_disasm_line(curr_addr, 1)
        if "push" in ins and "a4" in ins:
            hash_val= idc.get_operand_value(curr_addr, 0)
            hash_lst.append([hash_val, addr])
            break

        prev_addr= idc.prev_head(curr_addr)
        curr_addr=prev_addr

#print(hash_lst)

for i in hash_lst:
    try:
        api_res= (api_hash_map[i[0]])
        idc.set_cmt(i[1], f'   {api_res}', 0)
        func_caller= int(idc.get_func_name(i[1]).replace("sub_",""),16)
        idc.set_name(func_caller, f"mw_{api_res}",idaapi.SN_CHECK)
    except:
        print(i[0])
        print(f"not found: {i[1]}")
```

+ Kết quả:

![image](https://user-images.githubusercontent.com/91442807/215303473-edfda926-5ac1-4c20-95f9-8d973b1eec74.png)

## 4. C2 address

+ Chuyển qua xem phần `data section thử` và tìm ref đến nó:

![image](https://user-images.githubusercontent.com/91442807/215305674-2c15b929-5a30-4461-9cf6-c36bcb326c68.png)

+ Kéo lên trên là:

![image](https://user-images.githubusercontent.com/91442807/215305700-5e5b1574-ba81-40cd-b790-d4e4c72fe2fa.png)

+ Cái format này rất giống của 1 địa chỉ IP

- Có khả năng là phần data chính là ip address bị encrypt 

- hàm decrypt `IP_addr_dec` hoạt động tương tự như 2 cái trên nên ta chỉ cần dùng script cũ để decrypt

+ Sau đó chuyển kết quả thành địa chỉ IP:

```python
ip_lst=b"3K!z\x01\xbb\x00\x01\xba\xfa0\x05\x00P\x00\x01\xa8w'v\x01\xbb\x00\x01\xcf\x94Qw\x1f\x90\x00\x01\xc2\t\xack\x1f\x90\x00\x01\x8b\xc4H\x9b\x1f\x90\x00\x01N/\xccP\x01\xbb\x00\x01\x9fE\xed\xbc\x01\xbb\x00\x01-G\xc3h\x1f\x90\x00\x016%j\xa7\x1f\x90\x00\x01\xb9\xa8\x82\x8a\x01\xbb\x00\x01%,\xf4\xb1\x1f\x90\x00\x01\xb9\xb8\x19N\x1f\x90\x00\x01\xb9\x94\xa8\x0f\x1f\x90\x00\x01\x80\xc7\xc0\x87\x1f\x90\x00\x01%;\xd1\x8d\x1f\x90\x00\x01g)\xcc\xa9\x1f\x90\x00\x01\xb9\x94\xa8\xdc\x1f\x90\x00\x01g*:x\x1b\xa8\x00\x01N.I}\x01\xbb\x00\x01D\xb7]\xfa\x01\xbb\x00\x01\xbeZ\xe9B\x01\xbb\x00\x01\x058\x84\xb1\x1f\x90\x00\x01>\xab\xb2\x93\x1f\x90\x00\x01\xc4,b\xbe\x1f\x90\x00\x01\xa8\xc5\xfa\x0e\x00P\x00\x01B*9\x95\x01\xbb\x00\x01;\x94\xfd\xc2\x01\xbb\x00\x01h\x83>0\x1f\x90\x00\x01\xbf\xfcg\x10\x00P\x00\x016%\xe4z\x01\xbb\x00\x01X\xd9\xac\xa5\x1f\x90\x00\x01\xc3M\xef'\x1f\x90\x00\x01t|\x80\xce\x1f\x90\x00\x01]h\xd1k\x1f\x90\x00\x01vbHV\x01\xbb\x00\x01\xd9\xb6\x8f\xcf\x01\xbb\x00\x01WjaS\x1b\xa8\x00\x01\xd29\xd1\x8e\x1f\x90\x00\x016&\xf2\xb9\x01\xbb\x00\x01\xc3\x9a\x92#\x01\xbb\x00\x01\xcb\x99\xd8.\x01\xbb\x00\x01\xc6\xc7bN\x1f\x90\x00\x01U\xd6C\xcb\x1f\x90\x00\x01"

ip_lst=ip_lst.split(b"\x00\x01")
ip_lst=ip_lst[:-1]
from pwn import *
for i in ip_lst:
    port= i[4:6].rjust(4,b"\x00")
    print(f'{i[0]}.{i[1]}.{i[2]}.{i[3]}:{u32(port, endian="big")}')
```

- Kết quả:

```
51.75.33.122:443
186.250.48.5:80    
168.119.39.118:443 
207.148.81.119:8080
194.9.172.107:8080 
139.196.72.155:8080
78.47.204.80:443   
159.69.237.188:443 
45.71.195.104:8080 
54.37.106.167:8080 
185.168.130.138:443
37.44.244.177:8080 
185.184.25.78:8080 
185.148.168.15:8080
128.199.192.135:8080
37.59.209.141:8080
103.41.204.169:8080
185.148.168.220:8080
103.42.58.120:7080
78.46.73.125:443
68.183.93.250:443
190.90.233.66:443
5.56.132.177:8080
62.171.178.147:8080
196.44.98.190:8080
168.197.250.14:80
66.42.57.149:443
59.148.253.194:443
104.131.62.48:8080
191.252.103.16:80
54.37.228.122:443
88.217.172.165:8080
195.77.239.39:8080
116.124.128.206:8080
93.104.209.107:8080
118.98.72.86:443
217.182.143.207:443
87.106.97.83:7080
210.57.209.142:8080
54.38.242.185:443
195.154.146.35:443
203.153.216.46:443
198.199.98.78:8080
85.214.67.203:8080
```








