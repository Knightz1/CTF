## Deobfuscate Opaque Predicates


![image](https://user-images.githubusercontent.com/91442807/203092445-d7f6a371-7253-4286-aca5-fdec970bd8f6.png)

- Chương trình lấy một **absolute jump (JMP)** và chuyển thành 2 **condition jump (JZ/JNZ)** và sẽ lấy một trong hai dựa trên **ZF flag** nhưng IDA lúc decompile lại không như vậy, nó sẽ cố lấy luôn 2 nhánh và decompile code dựa trên hai nhánh -> dẫn đến kết quả decompile sai !!!

-> Patch **condition jump** và chuyển thành **absolute jump**

```python
import idc

ea = 0
while True:
    ea =  min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, "74 ? 75 ?"),  # JZ / JNZ
              idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, "75 ? 74 ?"))  # JNZ / JZ
    if ea == idc.BADADDR:
    	break
    idc.patch_byte(ea, 0xEB)	# JMP
    idc.patch_byte(ea+2, 0x90)	# NOP JNZ/JZ
    idc.patch_byte(ea+3, 0x90)	# NOP following address
```

![image](https://user-images.githubusercontent.com/91442807/203093975-90dd4184-f84d-43bb-b026-53f069a4ff8b.png)

- Undefinded hết code rồi make code lại

```python
import ida_ua
import ida_name
import ida_bytes


def main():
    begin=ida_name.get_name_ea(idaapi.BADADDR, "start")  #get  addr of "start"
    end=begin+0xe2
    
    ida_bytes.del_items(begin,0,end)   #undefined code 

    ida_ua.create_insn(begin, ida_ua.insn_t())

if __name__=="__main__":
    main()
```

-> Kết quả:

![image](https://user-images.githubusercontent.com/91442807/203094919-8901f8ab-2822-4d1e-8c87-8d72f883cb8f.png)

- Áp dụng cái script cho mấy đoạn code phía trên nữa (mấy cái đoạn có đoạn jump)

![image](https://user-images.githubusercontent.com/91442807/203095496-09d27e1d-b5be-4708-93ac-2efd1a21dcb7.png)

```python
import ida_ua
import ida_name
import ida_bytes


def main():
    begin=ida_name.get_name_ea(idaapi.BADADDR, "start")  #get  addr of "start"
    end=begin+0xe2
    
    ida_bytes.del_items(0x401294,0,0x401294+0xe2)   #undefined code 

    ida_ua.create_insn(0x401294, ida_ua.insn_t())

if __name__=="__main__":
    main()
```

![image](https://user-images.githubusercontent.com/91442807/203098673-86897127-aa79-401f-ad9a-f35c5929869c.png)

- Hàm lấy 2 giá trị **EAX** và **ECX** là tham số

-> Nhìn code có vẻ đây là một hàm quan trọng -> coi xref nó thử, quay lại trước khi patch vì sau khi patch không thấy gì nữa :))

![image](https://user-images.githubusercontent.com/91442807/203099289-2fab6f0e-eb54-481e-b460-21d4b897fee9.png)

- Vì sau khi patch không thấy nữa nên ta in ra các địa chỉ gọi nó trước để có gì coi sau:

```python
import idautils
xor_chunk_addr = 0x401294	# address of the xoring function
for xref in idautils.CodeRefsTo(xor_chunk_addr, 0):
    print(hex(xref),end=", ")
```

```0x401397, 0x401423, 0x401502, 0x4015c6, 0x40164b, 0x40187a, 0x401b56, 0x401d8d, 0x401f90, 0x402094, 0x402156, 0x402226, 0x4024e2, 0x4026a8, 0x402805, 0x402896, 0x40292e```

## Decrypt function

![1](https://user-images.githubusercontent.com/91442807/203105173-2cf61e25-4a94-482b-b606-a1a2d958b18a.png)

![3](https://user-images.githubusercontent.com/91442807/203105203-1af97f95-7caf-4ece-ae10-5371f014f89c.png)


- Giá trị của **eax** (+0x400000) chính là địa chỉ của instruction sau khi gọi **loc_401294** -> do đó ta suy luận được rằng hàm **loc_401294** sẽ lấy các bytes từ địa chỉ đó trở đi **xor 0xa6** với độ dài bytes là giá trị của **ecx** 

- Script patch:

```python
import ida_bytes

data=idaapi.get_bytes(0x40139C,0x50)
# print(data)
ida_bytes.del_items(0x40139C,0,0x50)   #undefined code
for i in range(len(data)):
    xx=data[i]^0xa6
    idaapi.patch_byte(0x40139C+i,xx)

ida_ua.create_insn(0x40139C, ida_ua.insn_t())
```

-> Kết quả:

![image](https://user-images.githubusercontent.com/91442807/203107741-0efed604-25af-4ffa-9c87-263c8e4226a5.png)








