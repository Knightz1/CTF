```python
from ctypes import *
import unicorn as uc
import struct
from pwn import *

# This is just to print each instruction address as it's emulated
def emu(start_addr, end_addr):
    def hook_call(uc_engine, mem_type, address, size):
        eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP)
        #print(f"EIP: {hex(eip-0x10000)}")
        test= uc_engine.mem_read(eip,2)
        if test[0]==0xcc:
            #print("0xcc detected!!")
            new_eip = eip + (test[1]^0x8f)
            uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, new_eip)
        return True


    buf = open('Guloader_stage2.bin', 'rb').read()

    uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32)
    STACK_ADDR = 0x900000
    CODE_ADDR = 0x10000

    # Load shellcode into mem
    uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL)
    uc_engine.mem_write(CODE_ADDR, buf)

    # Set shellcode entrypoint
    uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR)

    # Setup the stack memory
    uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL)
    uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR)
    uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR)


    # This is our hook just for fun
    hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None)


    # Setup our arguments/buffers

    ECX_BUFF = 0x500000
    uc_engine.mem_map(ECX_BUFF, 0x1000, uc.UC_PROT_ALL)
    uc_engine.reg_write(uc.x86_const.UC_X86_REG_ECX, ECX_BUFF)

    # This sort of works like a 'push' to push the buffer address onto the stack
    EBP_BUFF = 0x600000
    uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL)
    uc_engine.mem_write(STACK_ADDR, struct.pack('<I',EBP_BUFF))


    ESI_BUFF = 0x700000
    uc_engine.mem_map(ESI_BUFF, 0x1000, uc.UC_PROT_ALL)
    uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESI, ESI_BUFF)


    ARG_BUFF = 0x400000
    uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL)
    uc_engine.mem_write(STACK_ADDR + 4, struct.pack('<I',ARG_BUFF))

    FN_START = start_addr + CODE_ADDR
    FN_END = end_addr + CODE_ADDR        # not get ret ins

    uc_engine.emu_start(FN_START, FN_END, 0, 0)

    buf_data= uc_engine.mem_read(ARG_BUFF,0x100)
    #print(buf_data)
    data_len=u32(buf_data[:4])
    real_data=buf_data[4:4+data_len]

    key = bytes.fromhex('3d4f0b6d845f58cbf8844e9ab35781156c68109175e8c42901f8ee2b78c4926631939c778b2a48e0d8ea0dd585')
    key=key[:len(real_data)]

    res=xor(real_data,key).replace(b'\x00', b'')
    return res

#emu(0x1644a, 0x167b6)

string_dec=[]

addr_map= [[91210, 92086], [83953, 85271], [90239, 91186], [120484, 121298], [114237, 117039], [113340, 114227], [99181, 101024], [35413, 36161], [36164, 36739], [26383, 35407], [17008, 26374], [44085, 44596], [43697, 44079], [36745, 36747], [40348, 43696], [160892, 161634], [160892, 161634], [101025, 102194], [104293, 107280], [107292, 110175], [110176, 113295], [95601, 96785], [102195, 103155], [103156, 104286], [97760, 99074], [88897, 90106], [85301, 88880], [92116, 93763], [94639, 95565], [93775, 94623], [118631, 120473], [117059, 118630], [96929, 97741]]

for i in addr_map:
    st_addr= i[0]
    ed_addr= i[1]
    try:
        print(emu(st_addr, ed_addr))
    except:
        print(f"Error: {hex(st_addr)}-{hex(ed_addr)}")

# print(emu(0x8d44, 0x8f83))
```

```python
from pwn import *
import idc
import idautils

string_dec_func_addr=0x25A28
name_list=[]

for xref in idautils.CodeRefsTo(string_dec_func_addr, 0):

    curr_addr= xref
    
    while True:
        
        prev_addr=idc.prev_head(curr_addr)
        inss=idc.generate_disasm_line(prev_addr, 1)
        
        if "call    sub_" in inss:
            name_list.append(inss[len('call    '):])
            break
        curr_addr=prev_addr

print(name_list)

xor_string_func=['sub_1644A', 'sub_147F1', 'sub_1607F', 'sub_1D6A4', 'sub_1BE3D', 'sub_1BABC', 'sub_1836D', 'sub_8A55', 'sub_8D44', 'sub_670F', 'sub_4270', 'sub_AC35', 'sub_AAB1', 'sub_8F89', 'sub_9D9C', 'sub_2747C', 'sub_2747C', 'sub_18AA1', 'sub_19765', 'sub_1A31C', 'sub_1AE60', 'sub_17571', 'sub_18F33', 'sub_192F4', 'sub_17DE0', 'sub_15B41', 'sub_14D35', 'sub_167D4', 'sub_171AF', 'sub_16E4F', 'sub_1CF67', 'sub_1C943', 'sub_17AA1']
res_lst=[]

import idc
for i in xor_string_func:
    start_addr=int(i.replace('sub_', ''),16)
    end_addr= idc.get_func_attr(start_addr,idc.FUNCATTR_END)-1

    res_lst.append([start_addr,end_addr])
print(res_lst)
```
