## 1. Thu nhập thông tin

- Dùng `Die`:

-> Compile bằng ` MS Visual C++ 2005`.

-> Sử dụng thư viện ` MFC library` 

-> High entropy -> có thể bị packed. 

-> File `.dll` `32bit`


- Dùng `PEbear`:

-> Chương trìng có 2 export functions là: `DllRegisterServer` và `DllUnregisterServer`


- Dùng `capa`:

![image](https://user-images.githubusercontent.com/91442807/214837286-963ac755-32f2-4099-a89d-ed30f4340a9c.png)

-> Có sử dụng thuật toán RC4.

## 2. Unpacking

- Nhận thấy chương trình sử dụng các API: `VirtualAlloc`, `NtResumeThread`, `WriteProcessMemory` -> process hollowing

- Có thể sử dụng `hollow_hunter` để dump các file process.

- Cách sử dụng:

```
hollows_hunter64 /loop
rundll32 mas_3.bin,#1
```
- Kết quả:

![image](https://user-images.githubusercontent.com/91442807/214843515-ec71cf3b-df86-4a0a-8a13-680ed40660ba.png)

-> Ta chọn file có dung lượng cao hơn

- Load vào PEbear:

![image](https://user-images.githubusercontent.com/91442807/214843701-423d9fdd-981a-414a-bdcd-40c7787fae09.png)

-> Mấy cái section được map hết ko lỗi.

## 3. Reverse

- Kết quả `capa explorer`:

![image](https://user-images.githubusercontent.com/91442807/214857211-a02779eb-25b9-46e8-bc56-a1fcfe9ac6a8.png)

-> Dùng thuật toán hashing `murmur3`: `Kết quả sau khi hash là giá trị 32-bit hoặc 128-bit`

- `import` section không có gì -> khả năng cao là `API resolve dynamically`

- `strings` section chỉ có 3 dòng -> khả năng là `string decryption dynamically`

- Hàm `DllRegisterServer`:

![image](https://user-images.githubusercontent.com/91442807/215014341-b73add34-6414-463b-8174-e8f1b1188cd4.png)

- Hàm `sub_41A1FD0`:

![image](https://user-images.githubusercontent.com/91442807/215014414-303783af-0647-45b8-8c60-36f77dc3d332.png)

-> Control flow flattening

- Không phân tích nổi nên ta sẽ quan sát các hàm được gọi nhiều (khả năng cao dùng dùng resolve API hay decrypt strings):

```python
import idc
import idautils

ea= 0x41A1FD0

start = idc.get_func_attr(ea, FUNCATTR_START)
end_d = idc.get_func_attr(ea, FUNCATTR_END)
end=end_d -1

while start<=end:
    curr_addr= start
    ins= idc.generate_disasm_line(curr_addr,1)
    if "call" in ins and "sub_" in ins:
        func_addr= idc.get_operand_value(curr_addr,0)
        func_xref= len(list(idautils.CodeRefsTo(func_addr, 0)))
        print("\n")
        print(f"{ins} - {func_xref}")

        ea1= func_addr
        start1 = idc.get_func_attr(ea1, FUNCATTR_START)
        end1_d = idc.get_func_attr(ea1, FUNCATTR_END)
        end1=end1_d -1

        while start1 <= end1:
            curr_addr1= start1
            ins1= idc.generate_disasm_line(curr_addr1,1)
            if "call" in ins1 and "sub_" in ins1:
                func_addr1= idc.get_operand_value(curr_addr1,0)
                func_xref1= len(list(idautils.CodeRefsTo(func_addr1, 0)))
                print(f"    {ins1} - {func_xref1}")

            next_addr1= idc.next_head(curr_addr1)
            start1= next_addr1

    next_addr= idc.next_head(curr_addr)
    start= next_addr
```

- Kết quả:

![image](https://user-images.githubusercontent.com/91442807/215236936-dcb86384-6beb-43e3-8911-175045e94f02.png)

- Quan sát thì ta thấy `sub_4194BB4` được gọi khá nhiều với 45 lần.

- 1 hàm gọi nó:

![image](https://user-images.githubusercontent.com/91442807/215237015-feffa35e-3edf-4ab5-8599-06a5690e468d.png)

- Ta thấy có sử dụng `mảng dword` ở tham số thứ 2 mà mảng này lại nằm ở phần `.text section` -> khả năng là `string decryption`

- Vô coi thử:

![image](https://user-images.githubusercontent.com/91442807/215237221-50363866-0751-41de-95ce-576ba00d2232.png)

![image](https://user-images.githubusercontent.com/91442807/215237199-3786a8e3-e84c-4181-907d-d4c423a4023e.png)

-> Ta thấy `v6` giữ giá trị `ecx` tức là tham số thứ 2, sau đó `xor 4_bytes_đầu với 4_bytes_tiếp_theo làm độ dài`, sau đó lấy số lượng bytes tiếp theo dựa trên độ dài đó và xor với 4 bytes đầu.

-> Vậy là chỉ cần tham số thứ 2 của hàm, không liên quan đến các tham số kia.

- Script lấy địa chỉ tham số thứ 2 của hàm: 

```python
from pwn import *
import idc
import idautils


ea= 0x4194BB4
ref_lst= list(idautils.CodeRefsTo(ea, 0))
# print(ref_lst)
dword_lst=[]

for addr in ref_lst:
    curr_addr= addr
    ins_cnt=0
    while True:
        ins= idc.generate_disasm_line(curr_addr, 1)
        if "ecx" in ins and "offset dword_" in ins:
            dword_addr= idc.get_operand_value(curr_addr, 1)
            dword_lst.append(dword_addr)
            break

        prev_addr= idc.prev_head(curr_addr)
        curr_addr=prev_addr
        ins_cnt+=1
        if ins_cnt>=8:
            dword_lst.append(f"{hex(addr)} - error")
            break

assert(len(dword_lst) == len(ref_lst))
print(dword_lst)
```
-> Trong đó có một số địa chỉ không theo điều kiện tìm kiếm của script nên in error(quá lần cnt, không có dword trong ins,...), nên ta sửa lại mấy cái đó bằng tay

- Script decrypt:

```python
from pwn import *

dword_lst=[68753492, 68751872, 68752824, 68753176, 68752872, 68751872, 68751968, 68751872, 68752824, 68753128, 68752872, 68752824, 68751872, 68752016, 68753420, 68751872, 68751920, 68752096, 68753220, 68753392, 68752968, 68752872, 68753016, 68753300, 68753348, 68753588, 68753460, 68753096, 68753016, 68752968, 68752936, 68753064, 68752872, 68751920, 68751636, 68752016, 68751920, 68752584, 68751872, 68753460, 68753540, 68753492, 0x4191084, 0x41910E4]
#0x41a0b16 - error
dword_lst1=[0x4191494, 0x4191344, 0x4191364, 0x4191454, 0x4191324, 0x4191394, 0x41913C4, 0x4191424, 0x41913F4]

for dword_addr in dword_lst1:
    
    data_len= u32(idaapi.get_bytes(dword_addr,4)) ^ u32(idaapi.get_bytes(dword_addr,8)[4:])
    enc_data= idaapi.get_bytes(dword_addr,8+data_len)[8:]
    key_xor= idaapi.get_bytes(dword_addr,4)
    dec_data= xor(key_xor, enc_data)
    # print(dec_data)
    idc.set_name(dword_addr, dec_data.decode(), idaapi.SN_FORCE)
```
- Kết quả:

```
b'%s%s.exe'
b'%s\\%s'
b'ECCPUBLICBLOB'
b'ECDSA_P256'
b'Microsoft Primitive Provider'
b'%s\\%s'
b'%s\\%s%x'
b'%s\\%s'
b'ECCPUBLICBLOB'
b'ECDH_P256'
b'Microsoft Primitive Provider'
b'ECCPUBLICBLOB'
b'%s\\%s'
b'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
b'POST'
b'%s\\%s'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'%s\\regsvr32.exe /s "%s\\%s" %s'
b'%s:Zone.Identifier'
b'WinSta0\\Default'
b'SHA256'
b'Microsoft Primitive Provider'
b'ObjectLength'
b'%s\\*'
b'%s\\%s'
b'%s\\regsvr32.exe /s "%s"'
b'%s%s.dll'
b'KeyDataBlob'
b'ObjectLength'
b'SHA256'
b'HASH'
b'AESR'
b'Microsoft Primitive Provider'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'Content-Type: multipart/form-data; boundary=%s\r\n'
b'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
b'%s\\regsvr32.exe /s "%s\\%s"'
b'RNG\xdf'
b'%s\\%s'
b'%s%s.dll'
b'%s\\regsvr32.exe /s "%s" %s'
b'%s%s.exe'
b'%u.%u.%u.%u'
b'Cookie: %s=%s\r\n'
```

```
b'advapi32.dll'
b'bcrypt.dll'
b'shell32.dll'
b'urlmon.dll'
b'userenv.dll'
b'crypt32.dll'
b'shlwapi.dll'
b'wininet.dll'
b'wtsapi32.dll'
```

- Tiếp đến ta coi thử hàm `sub_41AEAA3` được gọi 33 lần:

![image](https://user-images.githubusercontent.com/91442807/215240965-7459fa3f-f1b2-4e27-878d-b3bf5d64807d.png)

- Xem tiếp `sub_419645E`:

![image](https://user-images.githubusercontent.com/91442807/215240975-670473b4-4e8b-4167-9bad-340cac6c55ec.png)

-> Ta thấy `v1` được dùng làm hàm của các tham số -> có thể là API hashing

-> ref vô hàm `sub_41ABFF0` rất nhiều càng củng cố giả thuyết

- sub_41ABFF0:

![image](https://user-images.githubusercontent.com/91442807/215258878-c73a3841-7b4e-46b3-a0f4-332fd17908f1.png)

-> `v4` giữ giá trị `ecx` tức là `giá trị hex` rồi đưa vào hàm `sub_41B1AE9`:

![image](https://user-images.githubusercontent.com/91442807/215258934-897e0fa1-333b-4942-a512-74650a0b8c0c.png)

(Hình trên là kết quả sau khi `add struct`, `chỉnh sửa cấu trúc hàm các thứ`, ..)

-> Nhớ 1 điều rằng `InLoadOrderModuleList` sẽ trỏ tới struct [LDR_MODULE](http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FLDR_MODULE.html)

-> Vậy hàm này dùng để `resolve DLL`

- Qua hàm `sub_41AB558`:

![image](https://user-images.githubusercontent.com/91442807/215271044-cee28417-0167-419f-9dc7-6d6b424a651a.png)

-> Có vẻ hàm có sử dụng hàm `calculate_api_hash`

-> Hàm `calculate_api_hash` tương tự `calculate_dll_hash`, chỉ khác ở chỗ là không có bước đổi kí tự in hoa thành in thường.

-> Trace ngược lại ta thấy tham số cuối của `sub_41ABFF0` chính là giá trị hash của API cần so sánh:

![image](https://user-images.githubusercontent.com/91442807/215270608-191ad116-c04f-4a22-9dde-1c6cb7bd9fff.png)

-> Vậy giờ ta chỉ cần viết sccipt để brute các API thôi còn DLL thì ko cần quan tâm

```python
import json

json_data=json.loads(open("API_list.txt", "rb").read())
API_names=json_data['exports']

api_hash_map={}
def api_hash(api):
    i=0
    for j in range(len(api)):
        i = ((i << 0x10) + (i << 6) + api[j] - i)&0xffffffff
    return i ^ 0x32C9DB43

#print(api_hash(b'GetProcessHeap'))
for i in API_names:
    api_hash_map[api_hash(i.encode())]= i


ea= 0x41ABFF0

import idc
import idautils

ref_lst= list(idautils.CodeRefsTo(ea, 0))
hash_lst=[]

for addr in ref_lst:
    curr_addr= addr

    while True:
        ins= idc.generate_disasm_line(curr_addr, 1)
        if "push" in ins and "a4" in ins:
            hash_val= idc.get_operand_value(curr_addr, 0)
            hash_lst.append([hash_val, addr])
            break

        prev_addr= idc.prev_head(curr_addr)
        curr_addr=prev_addr

#print(hash_lst)

for i in hash_lst:
    try:
        api_res= (api_hash_map[i[0]])
        idc.set_cmt(i[1], f'   {api_res}', 0)
        func_caller= int(idc.get_func_name(i[1]).replace("sub_",""),16)
        idc.set_name(func_caller, f"mw_{api_res}",idaapi.SN_CHECK)
    except:
        print(i[0])
        print(f"not found: {i[1]}")
```

+ Kết quả:

![image](https://user-images.githubusercontent.com/91442807/215303473-edfda926-5ac1-4c20-95f9-8d973b1eec74.png)








