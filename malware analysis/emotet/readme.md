## 1. Thu nhập thông tin

- Dùng `Die`:

-> Compile bằng ` MS Visual C++ 2005`.

-> Sử dụng thư viện ` MFC library` 

-> High entropy -> có thể bị packed. 

-> File `.dll` `32bit`


- Dùng `PEbear`:

-> Chương trìng có 2 export functions là: `DllRegisterServer` và `DllUnregisterServer`


- Dùng `capa`:

![image](https://user-images.githubusercontent.com/91442807/214837286-963ac755-32f2-4099-a89d-ed30f4340a9c.png)

-> Có sử dụng thuật toán RC4.

## 2. Unpacking

- Nhận thấy chương trình sử dụng các API: `VirtualAlloc`, `NtResumeThread`, `WriteProcessMemory` -> process hollowing

- Có thể sử dụng `hollow_hunter` để dump các file process.

- Cách sử dụng:

```
hollows_hunter64 /loop
rundll32 mas_3.bin,#1
```
- Kết quả:

![image](https://user-images.githubusercontent.com/91442807/214843515-ec71cf3b-df86-4a0a-8a13-680ed40660ba.png)

-> Ta chọn file có dung lượng cao hơn

- Load vào PEbear:

![image](https://user-images.githubusercontent.com/91442807/214843701-423d9fdd-981a-414a-bdcd-40c7787fae09.png)

-> Mấy cái section được map hết ko lỗi.

## 3. Reverse

- Kết quả `capa explorer`:

![image](https://user-images.githubusercontent.com/91442807/214857211-a02779eb-25b9-46e8-bc56-a1fcfe9ac6a8.png)

-> Dùng thuật toán hashing `murmur3`: `Kết quả sau khi hash là giá trị 32-bit hoặc 128-bit`

- `import` section không có gì -> khả năng cao là `API resolve dynamically`

- `strings` section chỉ có 3 dòng -> khả năng là `string decryption dynamically`

- Hàm `DllRegisterServer`:

![image](https://user-images.githubusercontent.com/91442807/215014341-b73add34-6414-463b-8174-e8f1b1188cd4.png)

- Hàm `sub_41A1FD0`:

![image](https://user-images.githubusercontent.com/91442807/215014414-303783af-0647-45b8-8c60-36f77dc3d332.png)

-> Control flow flattening

- Không phân tích nổi nên ta sẽ quan sát các hàm được gọi nhiều (khả năng cao dùng dùng resolve API hay decrypt strings):

```python
import idc
import idautils

ea= 0x41A1FD0

start = idc.get_func_attr(ea, FUNCATTR_START)
end_d = idc.get_func_attr(ea, FUNCATTR_END)
end=end_d -1

while start<=end:
    curr_addr= start
    ins= idc.generate_disasm_line(curr_addr,1)
    if "call" in ins and "sub_" in ins:
        func_addr= idc.get_operand_value(curr_addr,0)
        func_xref= len(list(idautils.CodeRefsTo(func_addr, 0)))
        print("\n")
        print(f"{ins} - {func_xref}")

        ea1= func_addr
        start1 = idc.get_func_attr(ea1, FUNCATTR_START)
        end1_d = idc.get_func_attr(ea1, FUNCATTR_END)
        end1=end1_d -1

        while start1 <= end1:
            curr_addr1= start1
            ins1= idc.generate_disasm_line(curr_addr1,1)
            if "call" in ins1 and "sub_" in ins1:
                func_addr1= idc.get_operand_value(curr_addr1,0)
                func_xref1= len(list(idautils.CodeRefsTo(func_addr1, 0)))
                print(f"    {ins1} - {func_xref1}")

            next_addr1= idc.next_head(curr_addr1)
            start1= next_addr1

    next_addr= idc.next_head(curr_addr)
    start= next_addr
```







